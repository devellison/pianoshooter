<?xml version="1.0" encoding="iso-8859-1" ?>
<ZApplication Name="App" Caption="ZGameEditor application" AmbientLightColor="0.502 0.502 0.502 1" CustomScreenWidth="1" CameraPosition="-3.2 16.8 161.8" ClipNear="0.01" ClipFar="1000" FileVersion="2">
  <OnLoaded>
    <ZExternalLibrary ModuleName="ZGameEditor Visualizer">
      <Source>
<![CDATA[// ZGameEditor Visualizer built-in functions
void ParamsReadValueForLayer(xptr Handle, int Layer, int Param, ref float Value) {}
void ParamsWriteValueForLayer(xptr Handle, int Layer, int Param, float NewValue) {}
void ParamsChangeName(xptr Handle,int Layer, int Param, string NewName) {}
string ZgeVizGetEffectName(xptr Handle, int LayerNr) {}]]>
      </Source>
    </ZExternalLibrary>
    <ZLibrary Name="PianoLib" Comment="Piano related functions">
      <Source>
<![CDATA[// Long term, this should become a real float printer?
// Ryu's method is a lot of code though.
string impFloatToStr(float fval)
{
   string theString;
   // yeah, fix this.
   theString = "(" + intToStr(fVal*1000) + "/1000)";
   return theString;
}

// Dump all parameters to trace.
void DumpParameters()
{
   for (int i = 0; i < Parameters.SizeDim1; i++)
   {
     float pval = Parameters[i];
     trace("Parameter " + intToStr(i) + " = " + impFloatToStr(pval));
   }
}

vec3 getColor(int channel, int noteIndex)
{
  vec3 curColor;
  int colorSet = Parameters[P_COLOR_PALETTE] * 1000;

  if (Parameters[P_COLOR_CHANNEL] > 0.5)
  {
    curColor[0] = ChannelColors[colorSet,channel,0];
    curColor[1] = ChannelColors[colorSet,channel,1];
    curColor[2] = ChannelColors[colorSet,channel,2];
  }
  else
  {
    int index = floor(noteIndex / 8.5);
    float distance = (noteIndex - floor(noteIndex/8.5)*8.5)/16.0;

    vec3 color1;
    vec3 color2;
    color1[0] = ChannelColors[colorSet,index,0];
    color1[1] = ChannelColors[colorSet,index,1];
    color1[2] = ChannelColors[colorSet,index,2];
    color2[0] = ChannelColors[colorSet,index+1,0];
    color2[1] = ChannelColors[colorSet,index+1,1];
    color2[2] = ChannelColors[colorSet,index+1,2];

    curColor[0] = color1[0]*(1.0 - distance) + color2[0]*distance;
    curColor[1] = color1[1]*(1.0 - distance) + color2[1]*distance;
    curColor[2] = color1[2]*(1.0 - distance) + color2[2]*distance;


  }


  return curColor;
}
// TODO - fix this.
// Really awful tap tempo - can we just query it?
// Ok - now we take a combo box so you can at least
// make it solid on tempos that match multiples of 10....
void FindTempo()
{
  int tempoType = floor(PARAMETERS[P_TEMPO]*1000);

  // Auto tempo.....
  if (tempoType == 0)
  {
    // The higher, the more accurate, but the longer it takes
    // for it to get or adjust a tempo.
    int numBeatsToAvg = 60;

    if (LastBeat > SongPositionInBeats)
    {
      LastBeatTime = App.Time;
      LastBeat = SongPositionInBeats;
      BeatCounter = 1;
    }
    else
    {
      BeatCounter = (BeatCounter +1 )% numBeatsToAvg;
      if (BeatCounter == 0)
      {
        if (LastBeatTime != 0)
        {
          float diff = (SongPositionInBeats - LastBeat)/(App.Time - LastBeatTime);
          float newTempo = diff * 60;
          if (Tempo == 0)
          {
            trace("Got initial tempo! It's " + IntToStr(newTempo));
          }
          Tempo = newTempo;
        }
        LastBeatTime = App.Time;
        LastBeat = SongPositionInBeats;
      }
    }
  }
  else
  {
    // List starts at 60 right now after auto, and goes up by 10 each time.
    Tempo = (tempoType - 1)* 10 + 60;
    // Fine adjust allows you to add 0-9 to the base
    int tempoFine = floor(PARAMETERS[P_TEMPO_FINE]*10);
    Tempo += tempoFine;
  }
}

// Kills all note models on their next update.
void clearNotes()
{
  trace("Clear Notes");
  for (int c = 0; c < 16; c++)
  {
     for (int n = 0; n < 128; n++)
     {
       if (ActiveNotes[n,c] != null)
       {
        ActiveNotes[n,c].noteIsActive = 0;
        ActiveNotes[n,c] = null;
       }
     }
  }
  ClearAllNotes = 1;
}

void clearKeys()
{
  trace("Clear Keys");
  for (int i = 0; i < 128; ++i)
  {
    KeyArray[i].isDown = 0;
  }
}

// Called when playing has started in FL Studio
void onPlayingStart()
{
  TotalNotes = 0;
  FinalNotes = 0;
  TotalNoteEnds = 0;
  isPlaying = 1;
}

// Called when playing ends
void onPlayingEnd()
{
  FinalNotes = TotalNotes;
  trace("Final notes: " + intToStr(FinalNotes) + " Unfinished Notes: " + IntToStr(TotalNotes - TotalNoteEnds));
  isPlaying = 0;
  clearNotes();
  clearKeys();
  //DumpParameters();
}

// Deactive note model when MIDI Note ends
void endNote(int c, int n, int key)
{
  if (ActiveNotes[n,c] != null)
  {
    ActiveNotes[n,c].noteIsActive = 0;
    ActiveNotes[n,c].totalDelta += app.DeltaTime;
  }
  ActiveNotes[n,c] = null;
}


// Create node model on MIDI start note
void createNote(int c, int n,float v, int key)
{
  if (ActiveNotes[n,c] != null)
  {
    endNote(c,n,key);
  }

  ActiveNotes[n,c] = createModel(NoteModel);
  if (Parameters[P_USE_VELOCITY] > 0.5)
  {
    ActiveNotes[n,c].vel = v/127.0;
  }
  else
  {
    ActiveNotes[n,c].vel = 1.0;
  }
  ActiveNotes[n,c].startTime = app.DeltaTime;
  ActiveNotes[n,c].noteIndex = n;
  ActiveNotes[n,c].noteIsActive = 1;
  ActiveNotes[n,c].noteChannel = c;
  ActiveNotes[n,c].Position.Y = NoteStart;
  ActiveNotes[n,c].Position.X = KeyArray[key].Position.X;
  ActiveNotes[n,c].Position.Z = KeyArray[key].Position.Z;
}

// Pick the piano key for a note, or -1 if out of range.
int keyFromNote(int note)
{
  int key = (note - FirstPianoKey);
  if (key < 0)
  {
     key = -1;
  }
  if (key >= NumPianoKeys)
  {
    key = -1;
  }

  // If the key is out of range, we can either ignore it
  // or transpose to fit our keyboard....
  if (key < 0)
  {
    // *which* key to use on transpose is a question
    // that needs more thought.
    if (Parameters[P_TRANSPOSE] > 0.5)
    {
      int noteLetter = note % 12;
      int start = FirstPianoKey % 12;
      int end = (FirstPianoKey + NumPianoKeys) % 12;

      key = (noteLetter + 12 - start) % 12;
      // Still can't do it?
      if (key >= NumPianoKeys)
      {
         key = -1;
      }
    }
  }

  return key;
}

// Called when a MIDI note starts
void onNoteOn(int channel, int note, int velocity)
{
  TotalNotes++;
 //  trace("Note on " +intToStr(channel) + ":" + intToStr(note) + " @ " + intToStr(velocity));
  NoteState[note,channel] = velocity;

  int key = keyFromNote(note);
  if (key >= 0)
  {
    if (PianoMode == 0)
    {
      KeyArray[key].isDown = 1;
      KeyArray[key].lastChannel = channel;

      KeyArray[key].Position.Y = KeyPositions[key,1] - 1;
    }
    createNote(channel,note,velocity, key);
  }
}

// Called when a MIDI note stops
void onNoteOff(int channel, int note, int velocity)
{
  TotalNoteEnds++;
//  trace("Note off " + intToStr(channel) + ":" + intToStr(note));
  NoteState[note,channel] = 0;
  int key = keyFromNote(note);
  if (key >= 0)
  {
    if (PianoMode == 0)
    {
      KeyArray[key].isDown = 0;
    }
    endNote(channel,note, key);
  }
}

// Update first/num keys and arg, returns > 0 if any changed.
int updateKeys()
{
  int changed = 0;
  int newNum  = floor(Parameters[P_NUM_KEYS]*116 + 12);
  int newFirst = floor(Parameters[P_FIRST_KEY]*116);
  float newArc = Parameters[P_ARC];

  if (newFirst + newNum >= 128)
  {
    newFirst = 128 - newNum;
  }

  if ((newNum != NumPianoKeys) ||
      (newFirst != FirstPianoKey) ||
      (newArc != PianoArc))
  {
    NumPianoKeys = newNum;
    FirstPianoKey = newFirst;
    PianoArc = newArc;
    changed = 1;
  }
  return changed;
}

// Set up the keyboard for number of keys and first key and current arc
void GenKeyboard(int firstKey, int numKeys, float arc)
{


  // Calc start of keyboard on X
  float arcKeySpacing = KeySpacing*.75;
  KeyStart = -(arcKeySpacing*numKeys*.5);
  int endPianoKey = firstKey + numKeys;

  for (int i = 0; i < 128; i++)
  {
      KeyArray[i].visible = 0;
      if (i >= endPianoKey)
      {
        KeyArray[i].isDown = 0;
      }
  }
  // Generate the piano keyboard
  for (int i = firstKey; i < endPianoKey; i++)
  {
    int key = i - firstKey;

    float flatPos = (i - 64.0) / 128.0;
    float arcPos  = PI - (PI * i/128.0);

    float flatLayoutX = flatPos * KeySpacing * 128;
    float flatLayoutZ = 0;

    float arcLayoutX =   arcKeySpacing  * 64 * cos(arcPos);
    float arcLayoutZ =  -arcKeySpacing  * 64 * sin(arcPos);


    // KeyPositions holds the "Base" key positions with arc.
    // KeyArray objects have the actual current position, which may be
    // modified by a press.

    // So this averaging mostly works, but the key spacing isn't great inbetween states.
    // TODO: Fix it.
    KeyPositions[key,0] = arcLayoutX*arc + ((1.0 - arc)* flatLayoutX );
    KeyPositions[key,1] = 0;
    KeyPositions[key,2] = arcLayoutZ*arc + ((1.0 - arc) * flatLayoutZ );

    KeyArray[key].visible = 1;
    KeyArray[key].NoteValue = i;

    // Set Key objects to their new default position
    KeyArray[key].Position.X = KeyPositions[key,0];
    KeyArray[key].Position.Y = KeyPositions[key,1];
    KeyArray[key].Position.Z = KeyPositions[key,2];

    KeyArray[key].Rotation.Y = -.5*((i - 64.0)/128.0) * arc;
  }
}



//---------------------------------------------------------------------------
//
// FL Studio message entry points.
//
//---------------------------------------------------------------------------
void OnHostMessage(int id, int index, int value)
{
  switch (id)
  {
  case 12:
    if (value > 0)
      onPlayingStart();
    else
      onPlayingEnd();
    break;
  default:
    trace("Host: " + intToStr(id)
                + ":" + intToStr(index)
                + ":" + intToStr(value));
  }
}

void OnMidiMessage(int status, int data1, int data2)
{
  //trace("Got midi " + intToStr(status)
  //               + ":" + intToStr(data1)
  //               + ":" + intToStr(data2));
  int channel = status & 0x0f;
  int opcode = status & 0xf0;

  switch (opcode)
  {
    case 0x80:
      onNoteOff(channel, data1,data2);
      break;
    case 0x90:
      onNoteOn(channel, data1,data2);
      break;
    case 0xa0: // polyphonic aftertouch
      //trace("PAT ch " + intToStr(channel));
      break;
    case 0xb0: // control change
      //trace("CC ch " + intToStr(channel));
      break;
    case 0xc0: // program change
      //trace("PC ch " + intToStr(channel));
      break;
    case 0xd0: // aftertouch
      //trace("AT ch " + intToStr(channel));
      break;
    case 0xe0: // Pitch wheel
      //trace("PW ch " + intToStr(channel));
      break;
    case 0xf0: // system messages
      //trace("SYS");
      break;
    default: // ?
      trace("UNKNOWN MIDI: " + IntToStr(status) + "," + IntToStr(data1) + "," + IntToStr(data2));
      break;
  }
}

// Give a knob an exponential feel.
// Large powers weight to large values.
float expKnobFunc(float x, float power)
{
  return (1.0 - (1.0 - pow(x,power)));
}

// Returns 1 if it's a flat/sharp black key,
//         0 if it's a natural white key.
int isNoteBlack(int theNote)
{
  int isItBlack = 1;
  switch(theNote % 12)
  {
    case 0: //c
    case 2: //d
    case 4: //e
    case 5: //f
    case 7: //g
    case 9: //a
    case 11: //b
      isItBlack = 0;
      break;
  }

  return isItBlack;
}]]>
      </Source>
    </ZLibrary>
    <ZLibrary Name="PianoLinkLib" HasInitializer="1">
      <Source>
<![CDATA[// If we just blindly write every cycle, it can cause a crash at the end
// of rendering the real video.  So we have to buffer parameters
// and only write them when they are individually changed.
float[P_NUM_PARAMS] ParamBuffer;
int ParamsInitialized = 0;
// Plugin and layer for linking to other visualizer layers.
xptr FLPluginHandle;
int LayerNr;]]>
      </Source>
    </ZLibrary>
    <ZExpression Name="InitializeKeys">
      <Expression>
<![CDATA[// Save Viewport
ViewPortSize=vector2(app.ViewportWidth,app.ViewportHeight);

// Fill the note array with null
for (int i = 0; i < 128; i++)
{
  for (int j = 0; j < 16; j++)
  {
    ActiveNotes[i,j] = null;
  }
  KeyArray[i] = createModel(PianoKeyModel);
  KeyArray[i].visible = 0;

  KeyArray[i].pressStep[0] = 0.3;
  KeyArray[i].pressStep[1] = 0.3;
  KeyArray[i].pressStep[2] = 0.3;
}

updateKeys();
GenKeyboard(FirstPianoKey,NumPianoKeys,PianoArc);]]>
      </Expression>
    </ZExpression>
  </OnLoaded>
  <OnUpdate>
    <ZExpression Name="PianoLink">
      <Expression>
<![CDATA[// This allows you to link all PianoShooters such that one controls
// the critical parameters of the other to keep them in sync.

// Means you only have to automate the one you check
if (Parameters[P_PIANOLINK] > 0.5)
{
  string test = "Looking for pianoshooters...";
  for (int curLayer = 0; curLayer < 100; curLayer++)
  {
    // SKip if it's us :)
    if (curLayer == LayerNr)
      continue;

    test = ZgeVizGetEffectName(FLPluginHandle,curLayer);
    if (test == "PianoShooter")
    {

      for (int i = 0; i < Parameters.SizeDim1; i++)
      {
        if ((ParamsInitialized == 0) || (Parameters[i] != ParamBuffer[i]))
        {
          switch (i)
          {
            // These should make sense if different / random.
            // With only two, might invert some of them?
            case P_SHOW_PIANO:
            case P_SHOW_NOTES:
            case P_SHOW_PARTICLES:
            case P_LIGHT_KEYS:
            case P_USE_VELOCITY:
            case P_NOTE_TYPE:
              break;

            // These should be linked
            case P_COLOR_PALETTE:
            case P_COLOR_CHANNEL:
            case P_NOTE_DIR:
            case P_TRANSPOSE:
            case P_PIANO_MODE:
            case P_PREROLL:
            case P_COLOR_PALETTE:
            case P_TEMPO:
            case P_TEMPO_FINE:
            case P_NOTE_SPEED:
            case P_KEYBOARD_ANGLE:
            case P_CAMERA_X:
            case P_CAMERA_Y:
            case P_CAMERA_Z:
            case P_CAMERA_YAW:
            case P_CAMERA_PITCH:
            case P_ARC:
            case P_NUM_KEYS:
            case P_FIRST_KEY:
              ParamsWriteValueForLayer(FLPluginHandle,curLayer,i, Parameters[i]);
              break;

            // This one.... maybe just make sure only one is set?
            case P_PIANOLINK:
              ParamsWriteValueForLayer(FLPluginHandle,curLayer,i, 0);
              break;
          }
          ParamBuffer[i] = Parameters[i];
        } // End if parameters uninitialized or changed.
      } // End for each parameter
    } // End if it's a pianoshooter layer
  } // End for each layer
  ParamsInitialized = 1;
} // END IF PIANOLINK]]>
      </Expression>
    </ZExpression>
    <ZExpression Name="PianoShooterLogic">
      <Expression>
<![CDATA[if (LastTime != 0)
{
  CurDelta = App.Time - LastTime;
}
LastTime = App.Time;

// Update camera starting position from sliders
App.CameraPosition.X = (Parameters[P_CAMERA_X]* 200) - 100;
App.CameraPosition.Y = (Parameters[P_CAMERA_Y]* 200) - 100;
App.CameraPosition.Z = 5 + (Parameters[P_CAMERA_Z]) * 200;


vec3 cameraPos = App.CameraPosition;
App.CameraRotation.X = 0;
App.CameraRotation.Y = 0;
App.CameraRotation.Z = 0;

// Apply Pitch first - we want to keep looking at the keyboard,
// so when we change the camera pitch, we change the camera location too.
cameraPos = App.CameraPosition;
vec3 cameraRot = App.CameraRotation;
float pitch = Parameters[P_CAMERA_PITCH]/4.0;
float pitchPi = -2*pitch*(PI);

App.CameraPosition.X = cameraPos[0];
App.CameraPosition.Y = cameraPos[1]*cos(pitchPi)-cameraPos[2]*sin(pitchPi);
App.CameraPosition.Z = cameraPos[1]*sin(pitchPi) + cameraPos[2]*cos(pitchPi);

App.CameraRotation.X = pitch;

// Now apply Yaw similarly
cameraPos = App.CameraPosition;
float yaw = Parameters[P_CAMERA_YAW];
float yawPi = -yaw*2*PI;

App.CameraPosition.X = cameraPos[0] * cos(yawPi) + cameraPos[2]*sin(yawPi);
App.CameraPosition.Y = cameraPos[1];
App.CameraPosition.Z = -cameraPos[0]*sin(yawPi) + cameraPos[2]*cos(yawPi);
App.CameraRotation.Y = yaw;


// If we set clear on a previous cycle, reset it now.
if (ClearAllNotes > 0)
{
  ClearAllNotes = 0;
}

// Get preroll
int preBeats = floor(Parameters[P_PREROLL]*1000);
switch (preBeats)
{
  case 0: PreRoll = 4; break;
  case 1: PreRoll = 6; break;
  case 2: PreRoll = 8; break;
  case 3: PreRoll = 12; break;
  case 4: PreRoll = 16; break;
  case 5: PreRoll = 24; break;
  case 6: PreRoll = 32; break;
  case 7: PreRoll = 48; break;
  case 8: PreRoll = 64; break;
}

// If first/num keys or arc changed, regen the keyboard
if (updateKeys() > 0)
{
  GenKeyboard(FirstPianoKey,NumPianoKeys, PianoArc);
}

// Update key angle from sliders
if (KeyAngle != Parameters[P_KEYBOARD_ANGLE])
{
  KeyAngle = Parameters[P_KEYBOARD_ANGLE];
  for (int i = 0; i < 128; i++)
  {
    KeyArray[i].Rotation.X = -KeyAngle/5.0;
  }
}


int curDir = Parameters[P_NOTE_DIR];

// Update current direction - if we change it, nuke existing notes.
if (curDir != NoteDirection)
{
  NoteDirection = curDir;
  clearNotes();
}

if (PianoMode != floor(Parameters[P_PIANO_MODE]*1000))
{
  PianoMode = floor(Parameters[P_PIANO_MODE]*1000) ;
  // Reset existing notes
  clearNotes();
}

// Update tempo as necessary if we're not in a selected tempo mode.
FindTempo();

// Update note speed from slider....
NoteSpeed = (Parameters[P_NOTE_SPEED] - 0.5)*NoteSpeedRange + NoteSpeedBase;
NoteStep = CurDelta * NoteSpeed;

// For player mode, start the notes 4 beats out
PlayerY =   PreRoll*NoteSpeed / (Tempo/60.0);

// Setup where notes start and their step size/direction
if (PianoMode == 0)
{
  NoteStart = 0;
}
else if (PianoMode == 1)
{
  NoteStart = PlayerY;
  NoteStep *= -1;
}

if (NoteDirection)
{
  NoteStart *= -1;
  NoteStep  *= -1;
}]]>
      </Expression>
    </ZExpression>
  </OnUpdate>
  <Content>
    <Group Name="FLStudio">
      <Children>
        <Constant Name="AuthorInfo" Type="2">
          <StringValue>
<![CDATA[Impostorem
http://www.impostorem.com]]>
          </StringValue>
        </Constant>
        <Constant Name="ParamHelpConst">
          <StringValue>
<![CDATA[Show Piano @checkbox
Show Notes @checkbox
Show Particles @checkbox
Light Keys @checkbox
Note Direction @checkbox
Transpose @checkbox
Show Velocity @checkbox
Color by Chan @checkbox
NoteType @list1000: Cuboid, Flat
Palette @list1000: Prime,Sunrise,Dusk, BlueSky, Rainbow,Fire,Grass,Pine,Icy, Bunnies, Bones, Grayscale
Piano @list1000: Shooter, Player
Preroll @list1000: 4,6,8,12,16,20,24,32,48,64
Tempo @list1000: Auto,60,70,80,90,100,110,120,130,140,150,160,170,180,190,200,210,220,230,240
 Fine @list: 0,1,2,3,4,5,6,7,8,9
PianoLink @checkbox
Note Speed
Keyboard Angle
Camera X
Camera Y
Camera Z
Camera Yaw
Camera Pitch
Key Arc
Num Keys
First Key]]>
          </StringValue>
        </Constant>
        <Variable Name="isPlaying" Type="1"/>
        <Array Name="Parameters" SizeDim1="25" Persistent="255">
          <Values>
<![CDATA[789C636068B06740C13080CE6760C81762B646E6D767D9D84199F6C7BDCDEDF5EFAAA0A887E9070031310A92]]>
          </Values>
        </Array>
        <Variable Name="SongPositionInBeats"/>
        <Variable Name="Tempo"/>
        <Group Name="ParameterIndicies">
          <Children>
            <Constant Name="P_SHOW_PIANO" Type="1"/>
            <Constant Name="P_SHOW_NOTES" Type="1" Value="1" IntValue="1"/>
            <Constant Name="P_SHOW_PARTICLES" Type="1" Value="2" IntValue="2"/>
            <Constant Name="P_LIGHT_KEYS" Type="1" Value="3" IntValue="3"/>
            <Constant Name="P_NOTE_DIR" Type="1" Value="4" IntValue="4"/>
            <Constant Name="P_TRANSPOSE" Type="1" Value="5" IntValue="5"/>
            <Constant Name="P_USE_VELOCITY" Type="1" Value="6" IntValue="6"/>
            <Constant Name="P_COLOR_CHANNEL" Type="1" Value="7" IntValue="7"/>
            <Constant Name="P_NOTE_TYPE" Type="1" Value="8" IntValue="8"/>
            <Constant Name="P_COLOR_PALETTE" Type="1" Value="9" IntValue="9"/>
            <Constant Name="P_PIANO_MODE" Type="1" Value="10" IntValue="10"/>
            <Constant Name="P_PREROLL" Type="1" Value="11" IntValue="11"/>
            <Constant Name="P_TEMPO" Type="1" Value="12" IntValue="12"/>
            <Constant Name="P_TEMPO_FINE" Type="1" Value="13" IntValue="13"/>
            <Constant Name="P_PIANOLINK" Type="1" Value="14" IntValue="14"/>
            <Constant Name="P_NOTE_SPEED" Type="1" Value="15" IntValue="15"/>
            <Constant Name="P_KEYBOARD_ANGLE" Type="1" Value="16" IntValue="16"/>
            <Constant Name="P_CAMERA_X" Type="1" Value="17" IntValue="17"/>
            <Constant Name="P_CAMERA_Y" Type="1" Value="18" IntValue="18"/>
            <Constant Name="P_CAMERA_Z" Type="1" Value="19" IntValue="19"/>
            <Constant Name="P_CAMERA_YAW" Type="1" Value="20" IntValue="20"/>
            <Constant Name="P_CAMERA_PITCH" Type="1" Value="21" IntValue="21"/>
            <Constant Name="P_ARC" Type="1" Value="22" IntValue="22"/>
            <Constant Name="P_NUM_KEYS" Type="1" Value="23" IntValue="23"/>
            <Constant Name="P_FIRST_KEY" Type="1" Value="24" IntValue="24"/>
            <Constant Name="P_NUM_PARAMS" Type="1" Value="25" IntValue="25"/>
          </Children>
        </Group> <!-- ParameterIndicies -->

      </Children>
    </Group> <!-- FLStudio -->

    <Group Name="PianoData" Comment="Data for the piano">
      <Children>
        <Array Name="ActiveNotes" Type="3" Dimensions="1" SizeDim1="128" SizeDim2="16"/>
        <Array Name="ChannelColors" Dimensions="2" SizeDim1="12" SizeDim2="16" SizeDim3="3" Persistent="255">
          <Values>
<![CDATA[789CD595FB4F545710C76F5293B689A66A8DF107DB6E4D63AC366AA2268DF1CE10DB3436A9D1D49A6862146D7F3026554CAA6D9AFEB02A2A34D022507CB4C2E25B50410544ACB0026235D0AE3C1AA008CB43457C21F58188D6F39DBBE7DE53E41F7093C97EEFBD67E6CC9CF399732CCBCF96FBF3F3B960903C1D25DF5A9A97B21519F7B4BF9FB4BED7DD6D5B03FC37C7C6BAFE7BF78C936FBD8FBEE5277DDF8BDEFDDB58F6FC6324D6B6A4E1E4F90F61ADAF767CE56AED73A668A6ABF3F3F2E869FF0FF2BC7FDF7BDC736F2D77DF5DC337BBBAE8E18375DCD8B09853929309739795CEE6CC804FC667674D6435B78DF7BFA48EE2D67078D6A387EB19B5650602F6DD3BABB9AEB696905747FB977CF2C409AAAAFC8CFEAE5BA8C6A7D2A68D1BE942C527FCE0FE37F4EBAE5D949F379DF11DE350F3D1231FD0F9F2724AFAF90DA9ADA6BA9A1EF7F6D28DCE4EFB9FC646793E9E9B6B5F696AA2ECAC2C422E788FB55339DA974321DAE0B748AFAADA07576FF0FB5DAD7235C604293E2ECE8656F5200E39E32DD63E2A1756F392E3EB43DDA28FE74EE5F8B8D754AE4936F67C4FE6BBB28F9743F3F974E1876A1F3AA8351CCD78467D2A5FBED1B9926BAA3FE781B9A839EC530505A2551D765565A5E8C38726507B5B9B68E52BEB01BD3D2D8DE2B6BE2A714E1716524AF248D10DF5F594BEFB2DD118ABFC59BDB37F4A1CC67927A72107CA487F9B4B8A89CF141551CEB1C97CE9E2A7B287785757FB050732DEE1D05FF338DCB24C58460D37BB56715BEB72A9018C0CE457AF9BA303AE56AC1BEF7D2E9717FF98C3DE9818D17F56CD75E33EE9EB238FD7E964CE77A5690927260C95B8EA9FAF5FBB46BA2FCACB3EC27ADB3AF6D62D5B06CD6560FE6AAF6D4F5B662F933166D01ACDDED76C44E2B83582A1C1D6010C1973B91ACC7831A35F582BFC101F9C207770E8680BFD271AB9EFDC31468F01DBA2913BB870C6040939402377701B8923F940231EF6CBF1F5496ED0F06BA85FA4E7923CA1F11D9C3B31A3256768FC3FEEFD8E35DB661F827DF400B41323241AECA307A09DB360A568B08F1E8006FBE80168B08F1E80468DF001FF601F3D0046C0397A00FC837DF400F807FBF806FEC13E7A0075817DD401FEC1BEB7070E47587F9C9F9A1DF86A761043B3132C61D6ECE4E64C61CD0EE6D3ECE0ECD3ECFCF7EC993EE7B9A5B999343B25C5C5A4D9C9484F27CD8E3AA349B373F6F759A4D9516B606B767066FE9FFF97B386B2D2524A4C4810C37D807C60FFF6F41058C29D12BBE915C69D71A1A282704EDCBE750B2CD0F6B4D18C6F78462EC9DB4648AE5987DF172E7E8C7F5DCECA23D9933835E54DE421E739D8C2FD053B7860BCE4082BC89F217726EC7CF9C78CBB0F565BB380EFDCFE5AACBD6D05E3AE84E1BE55B5D89EC97913B128C3FC86050C0B1A16364CCE9B880D37CC67D854C3A20C9B6F58B4613186F95D7B0E0B416B17]]>
          </Values>
        </Array>
        <Array Name="KeyArray" Type="3" SizeDim1="128"/>
        <Array Name="KeyPositions" Dimensions="1" SizeDim1="128" SizeDim2="3" Persistent="255">
          <Values>
<![CDATA[789C6DCE218A02010005D00926D32493C96432992C3BBBC164324D32994C269345100441181004614010840141100604417676B307F0001EC00318B6E90BFBD30B9FCF0F82E23778E582CFF884737CC407BCC719DEE12DDEE014AFF10A2F718217788E67788A27788C47788807B88F7B38C65DDCC16D1CE1166EE206AEE31AAEE20A0E711997F0F3E7ED07BEE31BBEE202E738C3294EF0140F718C235CC7A19F0BFEE0044776BE837F537CD08FD8C1057EE0F0939F38C2311EE2294E708A339CE3025FF10DDFF1033F71E9EBED320E710557710DD7710337710B47B88D3BB88B63DCC37D3CC0433CC2633CC1533CC373BCC0095EE2155EE3146FF016EF7086F7F8808F38C7277CC69797FF00C00C7F5F]]>
          </Values>
        </Array>
        <Array Name="NoteState" Type="1" Dimensions="1" SizeDim1="128" SizeDim2="16" Persistent="255">
          <Values>
<![CDATA[789CEDC1010D000000C2A0F74F6D0E37A00000000000000080770320000001]]>
          </Values>
        </Array>
        <Constant Name="Alignment"/>
        <Constant Name="KeyArcSpacing" Value="5"/>
        <Constant Name="KeySpacing" Value="1.5"/>
        <Constant Name="MaxModelY" Value="200"/>
        <Constant Name="NoteSpeedRange" Value="186" IntValue="186"/>
        <Constant Name="NoteSpeedBase" Value="100" IntValue="100"/>
        <Variable Name="BeatCounter" Type="1"/>
        <Variable Name="ClearAllNotes" Type="1"/>
        <Variable Name="CurDelta"/>
        <Variable Name="FinalNotes" Type="1"/>
        <Variable Name="FirstPianoKey" Type="1"/>
        <Variable Name="KeyAngle"/>
        <Variable Name="KeyStart"/>
        <Variable Name="LastBeat"/>
        <Variable Name="LastBeatTime"/>
        <Variable Name="LastTime"/>
        <Variable Name="NoteAlpha"/>
        <Variable Name="NoteDirection"/>
        <Variable Name="NoteSpeed"/>
        <Variable Name="NoteStart"/>
        <Variable Name="NoteStep"/>
        <Variable Name="NumPianoKeys" Type="1"/>
        <Variable Name="PianoArc"/>
        <Variable Name="PianoMode"/>
        <Variable Name="PlayerY"/>
        <Variable Name="Preroll"/>
        <Variable Name="SongBar" Type="1"/>
        <Variable Name="TotalNotes" Type="1"/>
        <Variable Name="TotalNoteEnds" Type="1"/>
        <Variable Name="ViewportSize" Type="6"/>
        <Model Name="NoteModel" Position="0 0 -1" Scale="1.5 1 1">
          <Definitions>
            <Variable Name="noteIndex" Type="1"/>
            <Variable Name="vel"/>
            <Variable Name="inNote" Comment="is the note hitting keyboard?"/>
            <Variable Name="noteChannel" Type="1"/>
            <Variable Name="noteIsActive"/>
            <Variable Name="startTime"/>
            <Variable Name="totalDelta"/>
            <Variable Name="notePosY"/>
            <Material Name="noteMaterial" Light="0" Shininess="0.05" Blend="2" DrawBackFace="255" Shader="noteShader">
              <Textures>
                <MaterialTexture Name="NoteTexture" TexCoords="1"/>
              </Textures>
            </Material>
            <Shader Name="noteShader" UpdateVarsOnEachUse="255">
              <VertexShaderSource>
<![CDATA[#version 120

uniform float uPianoMode;
uniform float uNoteDirection;
uniform float uVel;

varying vec4 fColor;

vec4 fPos;

#define uKeySpacing 1.5
#define PI 3.14159265358

void main()
{
  vec4 brightness;

  float shinyDir = abs(uPianoMode - uNoteDirection); // if ints, this'd be a xor

  fPos = gl_ProjectionMatrix * gl_ModelViewMatrix * gl_Vertex;
  float distance = sin(gl_Vertex.y) * (1.0 - shinyDir) +  (0.3 - sin(gl_Vertex.y))*(shinyDir);

  distance *= uVel;
  brightness = vec4(distance,distance,distance,1);

  fColor = (brightness + gl_Color);
  normalize(fColor);

  gl_Position = fPos;
}]]>
              </VertexShaderSource>
              <FragmentShaderSource>
<![CDATA[#version 120

varying vec4 fColor;

void main()
{
    gl_FragColor = fColor;
}]]>
              </FragmentShaderSource>
              <UniformVariables>
                <ShaderVariable Name="uPianoMode" VariableName="uPianoMode" VariableRef="PianoMode"/>
                <ShaderVariable Name="uNoteDirection" VariableName="uNoteDirection" VariableRef="NoteDirection"/>
                <ShaderVariable Name="uVel" VariableName="uVel" VariableRef="vel"/>
              </UniformVariables>
            </Shader>
            <Mesh Name="noteMesh">
              <Producers>
                <MeshImport>
                  <MeshData>
<![CDATA[789CED5AFB5F55D5BEFDCE0DB8017909BE80A4140C041F29BEC2505353D37C9F2CB3389946593ECA67A7A3E9E9F6504BD33A59462F527B989896A599A691F8C634C554500F861802CA4301853DBF778CB53D9F73EF0FF72FB8C5676D166BAF35E7777EBF638CEF98CBFABA44E6F90AFFDB79F3C07F0BFBFCE758763E33E7B623876B0B8A4412F71E28ACDF7FF2726555F51955F7A1F655C78233734A8A9F3F1E125CDEB02A323367E996ED4D45E6C6F408C8CEFBEA6B91E9E18B0AF7D564E7BDB6FEC35091CEFEB71D898DCE5F25D21010B254A4C2EDBBB24780487C93FAFD21C1E99F8AAC081E94B9B7B148ABA8F3170A8A9A4772E4356113F363A34546E496178CBFC2F3D3DF8BF83617E972ECF5DF448E9F2C3D2A527DC67DE8C55D22F991C782DB5765E6D4256F3A2312EE935E9C99239275B17A87C8BD65D9DFBE1FB7268C6B397B65441646A8CE58F37252F3C8CA2AACF6DADA0C91A1B5D3DE141955D763F1F193AAA54737615CE6E4C55D71C5272F33CE980B41D9220B1217E63126D5F28283ADBB9E0D09EE724C15F12C144972EF5AB2C12D72FE42AB28CE250B8FD7897C17913A446474CBA07E22214B4371257F954F8D48FAA7D330FB575F2F2F1739FD7D7D49E25ED50385BEDDE39B5456B50E13D9385AA475D8C6D1C3DB3092EF2244528714463186C3B5CCA76AE2DE6E31E73A75F62F280A6A23C2BB7283268D1799DF270EB52929AEACCA0D12E195B603EB4B44460E5B5EBE2050E4A14922ABC671F605813C8F4B673C953342EB36FBA316534536FBAF98CA95EC9B23B2C1BD6F4E7A71B84F66CEB2F322CC6A901351523CF39FDB9EB5D8D8A5BC20295EA4F4E8C23CE64724AFE78142F721D622C9CD4C38BFF1F96CABCC9C8D5D44CA0B72DB8BBCFEDBE89618AF1F31D62D665564794366CEB3AD5439CB06778FC58C84755910C81AE50665AC614E58C1EF22B2BFCDEB2972A090B9ADDE11941D73417583BBCF6C2F9493DCAA9C0B38A9E35F9C9BF5E58A86D6728D0BAF71ED5DAA999FB357368E665659B57BCB58AFAC8B41FD883A5EA99C51E126DA2BAB7A04D44F16F93074D6188EB66ADC8AE0BD8DB7A6F13C2EBD21607BD31983456E3BC28A4CCC27DE9E3FEEC5D8C861D3C33F0C7D6D3DEFFCEAEBE9E1DB9B2EDDC2F365E7D35288E1BA64E2B96947627B6602F1151E4BD4555611639CD77725EFCF5FD510B0B7F1A04C91A55BFA978A0CCAEC799599DAB58478525D11FCDAFA0915BCB3ED40DFE6FB6A161566E7852C55AD70137BE4DD3E54BA7E3F31B66BC92860B14700EF2166F22339C68A6059A89AE4CE5FA5DA1040FCE74756A71646A92E2AF4B25B757A3811EBDB3C392239223BEFF4F7AABECD678D21D35FDCA59A1F3972181560C6606A02595C50D4F52C5711EE43ADA89F4CEEC7A5530DB6A691F57D66136BC782A92A4EAD9071AA44AB28F228EB2211B26A1C554295DC57A52678D9D5E51851746F19D9312297B8A27A5456B51D48AD1855C7CCCCEF437D50E5D84403EB4D7EA9925FAA644D976A3205D123C3FB6A98ED9E57996755F25795D95B788DDC51256B54594755326542052B3BB496DCE95FCACAAE8A245F54994FF2F44021B149EC6DEC121ECBBCF33CB73D6B9D14CFBA07B5A94BA61E122DCFB64A4B610DBC2B9485897B8973AA684111739E9A487E758B5165157A04CC8D494D54A5C2A8520F559DAA9DA126A85227275410B1AAC461FF52A2F4F849B295394F4BD9574354AB12C3A35BAA06F5EB7995A81E5547367D17A1CA0C9005AAC47CEB30D58DA359CDB414EAAD2A953F35D1C1D362E661DA9BCCD5DA0C6635630DB33D228B35CAFE7641A0EA4393363951AA12A5AC6FF50E552270B33F303C951ACB7CA9EE9B931BA43A693CB5177165138754FBB862F682FA12F69AE5E5EC20D3AAD85F7C6AD85F42EB987F306B21D9CFEAC7155397D8BB182D1555F55019334954A726126FA175C4A44F0D9136AD8A185E5E4E14D5973CDB8ABA47452137A84B7D6673AD71E9E448FD64726A6B1A995839835C637F4C4B9931980C2542A6BD39721859336B0CB9A9CAAEA4CAAE44EC65AC210E4764517BA7BD4926F458BC6A1CB94CA4ADCDA08667AC6147189145343287CC2D7B81EAD05AD5696FF2373FD9BFA8D56929A3EA547B2C66D7E02CEC775DAA55590BB007E3B00FEEAB2172A8C08C877D70E135D5B5196D0792D14442F50E569F235063E7F721BBEF2DE315568AD17216D628630D9D405A0AB131222BEB229F65ADD766B02F34EDC80E55979C1C71A82C35716ECCBE1A22964ACB6C04F563F727ABD1B963C9E89909ECA4C42E9F2592EB92D97DD252E81CF82431C9B590BF546F2A4F5C312B959642BE748BA12721C6A8F05CFBA4F1EC3BE1B15C23F94BFDA776D597D039A4A5B01FCD4CA06351A58A92E1AA4417565AC53CAF98CA3CAF984AEDF5AA09334E94F2F7BE39C7EBBC08A1C6503F7D6AA8CFE00CFA5A5A0A7312D48F7A9B9AC85E801C438D55D90BA82FAAA175D464229359A27A83E9CE78D47C55F61DD53561EFC7C546D3E1A4A574F63FD729363ABE896FF79060F626CECF28D895B876BA97E6912F2785041F6C7DB035EFF15DC9EBD41C4403CD61EF000ADBABCE4CD8D845353C965D8CF7D09950D9784EAFD2BE8A59A242FAD45021799D7E863DD7AB56AAD44C5EA782B13B53A3E846A854F525416D54EB9293E255393B95906A0927D5C0B5308A9909F48DC406D741F5F6AA447D09734A0588B9204205E35CDE35D2C950BB7C6AA872BC429F43179196C2AEC42BF436E9C5AC02B54E95BD89911133EC41AA8551D5A9225DCF324B446278EC82C405895E0DE48844C2F036ECD3643167252AD88F662650077C6AA803AAE3AFB03AD481D03AE2B769472A03503699B82D29662DD8EFB82A628F33565651B7EB92A918AA272FB39A876B5959553A04F2343B8FB52E28A2F27831409FFC72123C792A7352973C1C0CE3EC0545E73AD1B7BF1F37FE4A4111B15159F57212DDE0C23CAEC87D8877B26B64E7F976A7AB67545E6F5F97CC6763A3793D24984EB869478E131B4DCE66E76D729C4ACC05E68A88F28E1C12BCEC3CB34DF71E1B4D95F63AE4F05876F0D868AEA8B28A3E796602D7C5D8D68471757492C41E7B3A3B1A11585E407C961EA53F0F093E7F8163121BDE7BD849E936F37AD22DD399A0CFC3338704D309C7464FCC67B4745FB1D17462DE1CC275ECE73D44A0FB105D1947666C4463E951BAE59060D6D78B0454663F33C01D506C3433062D061E98219E73F66E31CC272A974AE7C9CCA852DFB2F3981F6F7FC9CEA3ABEF1643FFE3CD52660ED99D9D47CC67E6905399395C634111F19999C3F80B8AFC255082A491F889AF34A80F0E7F1C6EB9AED5DADEC5EF7EF394EA53B8235AD6EA7821C69107DC7F073E03E4793C6371B8C4C04018E7F386D6AB9F9CD7463822A442A7E0DB0A5DA12DA45613A55EDB6386227CDB48AAF4A45A0D945BF1D414CC4503EFF33F46FADF9F57F4353DAD4325514A11C3358D97C5EA92E672BBB4C20C4D704F8D066126B7FC88B98CB491ED7A411264A024A8AF33B24B3A225A8F72346C4C71783F8DECD4B638BBAE1FEA598D92F6028B89B506C956C4176FFCB1D28D76A0044B17279206DD291BF52719A8A3E41E6734AB5FE93A8D3109C8CC367B11CF26C9BDFA0056F6EFE87DF0598EB84A94679734588AB4835CC65F6F6A0872F99073D7553DA5E7F447ED8E71464995FCA61552614B354CBB9979E6037D537762CDF5364A27C830B30B4F8FD52BFAB99E927464F30F5BAFB3B09E0064DAA3351A807103A54E5DCED8552ACE7A7F4775DC12EE54CA4F8E28EB102D19BA0FCF4C95EBB24637E80D7BAB8C910764ACFC2E59FAA936D199C87F7329D33918B35A8DFCAC134CB6DE2159B607B25A8DB14F6913E441F551ACDE5776A8B792DECA1829D647F40BACF41549C328EFCB2E3DAEDB6499E927EBED57762BD6F5A10C9501F2144670A1127E78B23122ACD6ABDA585A4BC8CD3C5ED7DFB50A5722A419B27745CB117508D61B29FEB8EB149E3E85BCBA1113B3598B9F2652894A1A698A18EAF50FFC7D047787483CAEEDD0307CDB03D5692433B0AA26A8FC14DCF512E2F405C6DC58B51B95BA021CB401D68A748FE6E91BC8D75DB240C8850854AA44C9208E7D5D43C194188C59A20DCA0C136D70C07A8BC421BE46721879C9D5045496AB0B74EAD35CA28094209C5769968E0202169805729B6CB161B2486F955844C3FAB981BC20E9656A91DFB1768F2E7270EDEF54D517CF33DB3077383BA1BF6A53B9533EC095A9CEF723751C22E92B3D659FDE23436486FCA233B4ABF95C5F9313760538E30FBE0E960BDA5A7663CE61C8A291ADD2022B2BC57AEB91B33FD4FF261F7D91311F202912EBF7953C3DA6CD705F34BE0DC5AAD60331DF2252E2D00F590CC05DE80732129FD1E014BA08981C2C67740CAE8DC0BCBF20BB71D21D79233F3DEAE5E619D4B25CE7423526EA7A54738DC34A7FB0E7777C334C2622825CDDAF7DA507F2FD13EEA9D4586989D9C2115533897432422C5D51B2A0052AE8C5905BEED37F62AEAF9D11DF00EE4781756FE90620F069647988BC07944580011518FF0BBD4BFFAE9FE839C9931F809C93607BAD7EADE9585F3A58BD13D79A490760F85DED87FA76C55A0648B2CC92D775299E7C4FDBC9DBA84C947CA6C7E45DBD0C949661AEF5983F16EB88D577E4037D46DE81D2AED66F107BAE1C42749F61E51BF56F58B15B0A11D5DD88BD17D6F13BF0D95207003755F29AFC4B6FD3294AA616A3726DF576BD5B0F2213879087ADB204888A97D5F225727A58BF95A3DA1315E98E91E6E9425CB3BA08C7AB60700346BE01DC7880E1BBE539CCCBDCBC27AFA27E0D3A5B96E05B2F0759214641FCB791BD4E4758ACDB50836950B308F0781AF256A577628ED9CA9C7F803906606D6950CC34E05CE4713C5DAAF36525D43B089C13CC889EACF3641EF0168F1193C0EF4A67C60E37B99F05665403BD9D1C7DFE4F77609711A0A802EA3D02CA32423AEBE3C8C514A0390C51B79275C0C019FB185050810AA6CA1E9D84D927CB190797FF57C7A90187EE41A51E00BF6FC3952D60C013A86D0B60760BAA2D4E0EFA2153B1F29C2C96187D0C99AD950BF28AAE46D59F46B613E4988E942750C967C19634E065A764CB6CA70379A081DFE9569DAF87B5971422832BF567D98C0C843A0836F2AB1E71AA70BB74847E9E4336EA9C956E049F059AB151D641F34EA3677597FB9D988F6817E9843CF3A9E3606D1E785306CD7A077CBEAE13651B6AD7147776C7778F613CB7F3547BDD83187F0263DF93B378F600D6D559FF0AAC889C449CBF42B32BC19A7F33C885DA1829D013BA0B19668502A12CCD303376AB78F6B2EE969FF177A56EC153EDD09DBC592D552AE36EADB56A9FD56ED20889FE15319C40DC6E47A76A80FBAE407FBD1E822E1BA72BC73A3DF6B80CC2792BACABB9D3BB545B6A53A0AC1CCE648FDDA09D91F749E8C10BD0F57D31AA20A3CDB0A25EBAC55ED1B3729F614EAEA16E5F6805BA79365657603F903227B65C7B06FADDC9D48ADA737602725CEEE4B097D9AF29E6045CCB8BBA180AD10148B88E6FEAD175A8B4BCEBB2CED46454B0B5E98839EED787702D04BE631BB4807AB505BA30448EC97609C6377BACD52F316E6F732F78F5B31EB3BB6D678CD50D3E231D7D7519BA39FDD636A87173E848B506E2A95CB4D61FB5BFB9210FEA8F36186BF533F53604B1F4379B71E73740FD47D092FB1DED5C238F398E8339DFAC5DB1E27BE51761DF7F0F679BF449DCFF30EE4BBBE97F36825795186183DE097C4C004EBFB46B6D2B196746E18779706395D560D16A60ED021064E407ED085D1D0924B117DF50AF9B32D0C4CFEC3C3CFDA879D93C6C2E01276BF15D2634B0B93C2ABD6F3AA837EC8B768936381D858E939DC3D7E9630F62BEFBCC2A30ED532BBA4AC79B345C69859F79E2F55A857A014C39AF63307B5BF902EBB905BD75223AA40123AF03135BC0BF5AD4CBDF6CD21CC9B77DF5945D2E91A68FF9D8EEB04FE8189364BA62AC563249C2D067B7D99DF657F40B8F53D94038BB9DF002DBA41BFA4C37A8691BA7831DD5EFC93A938A78EE947BE405D9640D8E22A02551B8BE2274D89FB48F0C80B6BE040EEC43E7EE8CCED1558FA00EB311DF0679C0CC018B8F68B55DA13EDA5B9F93E33ACAD4EB58F3B36D243BE11E79AD93EC966F853A7D1BEE5EA7F7E92B768464490A10BDC3DE638CDC8DA312B9DE0A97D0026ED025834D5B78C10C3068B7BE024C0A2ABE1CAA391CBDE786D27512B3F9404247288F47FF6AA2D40D6DDBAE21F0142D305E085CDF3FB1A6D3F649D34B13CC0E9D2E6FD99376ACCC30734C23E0E013FBB12DD34166825963D7D81A9D6DE69A6079D5B2FAEDCD211D8F5AD463AE0BE0B920237FC18C97ED8F380F365794791B2599B21868A6927D6C1BCB33E631B31E7F79F49AF59122FBB8D9ADB1584D2F8CF1AEBD055D7300B057089DF485F60E364150915F809CB6407523390B057C1B3DA75CEFC2BCBB34196B4D13BAE8A536587DE1F6A24CB079D45440A72A304B6FD42108881902856D818AD7004BBFEBDBA85984CC81F605C973761C9471B839A31FB15300CFC381A5E3364267D83BA0CEEFCA93A8EEE3FA2E56DC15AB7BDA1C028A26C33F67C1FBE6CB6F504283A8CF61E40B70527EE8D08FC2F97F04877B0DC7DBE853ED3413F787CA51C9B68960D11B6632705887E8D3A11549FA94A662757E1847317782099076E6030BAEA2FBED808AB737FB31E797D0F5300982CEB793BEE62A705B649FB31E4D34CBF1C441FCBDDD96EB363BD00C45DE6E80172330E6555D057D89112AE956255FFB0301D731CF32E8E8419D24F7982ED2D97150D859E94875A1032E851E5E9338D3C8CC02FEB6C0F50F30634D2890DE4892ED05BB4E5F3519D2047BB4BFE1F969B217AC6EB05FD86DC0F6BBB214F3FC848EB0DB7EAD7E7AB7B94B6A6408CEC6381EE20610EB42342B1D3FB24F3721936FE10E7FF33E14D14706DB68EB27EF9833E283BED0D87C055F6664349EFB145DE233B5F684F587663C6C9AE80E3CDBD3DC0D1C8F53B5831C2FB91DFE2707D90A806BEF8BFA5B7DD25ADBD98E9491A6D6DC6FFCE0972F637DFBF5804EB7B3ED5528E15C33D7A699E11A2E1D90F73078F0D1706CC3911371461059693E3616DC7D495F071E23C1BB27640A626C827D4B247ACF6D98F1337DCA16D8BE7251A6426F9603311FD862BBDE06A28AFDA1207741453374AFA602B33DA1FDEBD087AF6BAA894047BC6A87614E8FCCD62C78F52489D2B950F56F51D56C3D641A6C2FA9B58CC3DFF1FC1E0D342188340799F845DB9932D3CE0422778D51875FB8BB42B76C8B9F40D3C2F437CD80B932A7FBAFD7327BCD3E2D6126CA78C00FFA75EABDC1FEA44643D46DDDEA7255625F588BD143AC471A9B3D98FD3CBA732FF0EEBC3E817D6963789D776C0BB3CDE6998BC8FF59ECF03BD836526EE743350A651A74067B0BA990449B8EFDECBD32C8B491AFCC28C45DA907953B8A1E50855A7DC07E034CDC6FB2CD6A78380F3A559075C32D6C974A0905EB0E22BA933A482BE5B258299166A601DE632CFAFA33BA0058FE18BC8EB66FD9355A671EC4AEFD3C7AC06A1369A3D0292E1B1F6434182B1C0267FE047A428D7D1C08A17BAC70F652ED1C9FF78752A946A23EBEC6D7B8B1DAA6A8D4ADC6424F6E9544390D94FE0D8A54AB8FC82DD2181509971FD13BA3A40FB8715253EC77E0F74EF3AEE9232F83AD77DA3F6C0EFAD07C73C65EC2AC014E9FB9A1930DFBDDC796EF2658C9316638783CD2DE8FDEB6D4FC605AC3CFECD502CD051B93A437F276527798A6D21E9A721DDA9B0B2E7CA9D1D6571EB1C7CCB7F647707C07505F66BB221307C0A400B943B85F1D6B7E34DF9930FB0746F8DA4463BE4BE8903570E343B0A62BFA87289C41826D071C6EC6E809D08B53E01A744706D8B39A6AB7C29DBC67E2706F63B984EE142B77D914AC3558F69BE9761B7AC777E8F56150D11AECC4B2514776B38326DA24C90D4FB29C563F57037C7D26FC6931946F1DDC706F198C3DDE65EDA2A3E108FF0285CCD57FBF01CAD5D16686D44B77CC51AABB4C4B09865E3F64EFE3AEDDB412BEA3F2471E4F82B567B5A7ED6BAFE91630F20E68FF70A98783736B1576542598F971F4B5383897E7C08454742437F8D9094ADB13BAEF81667F0CDC7F8ADFD5FA10EEA222952223E2ECEF07E94C895776B133E80E3351AF97B0773F0107D707DEFE04546A99AD02824E60ED8BED5BEAB28F9940573DFACD31B8FA30B8D2D6E0DE6E6D665E322192A4BF4169B7830D97ECEBD873EFC49A0447B5F3462B4A8BF96E08EA1CE1E0A1317776D2D4BC849EFFA83D0B71DC853C279B8EF2B03D09967F6AB602733FC12F87C1B105C0AB3C20FF25F1F6157904BAF93D34E31DD3DA9ED2B7ECCF18B156AEC1E7A10F3BFDB9DE59A73A6FA37C9C5D451D3834451E44FD3E74BEBB077DFB6574B83A998BBF3BC97C7B807D107DF1307A7C3C3A5C2B79CFFA6B8EAE304374B2FD4D57832D1B6C07B88761E84607CD3EBD0435EE844ACDC50E61AF5D0475B94F47C3AFB4745D337570D31FA2BA6BED2AF3839D2B799EAD40BABFEB233349DE475CEF63572EF2A4BC05C4F9DB291651BB36433FCA3C11F2BCD96E3A988FE0226264173C5E9567307A4D0BD75C09354D6D3BE38B181FD501A6B12B5BBE91BE9825088EB7A32DF4B8A4DC649A8966B17D41D6DAE74D89C7CFB5D2F22D51B63C05049F43BC0FC2E16097E5F8FC3227177C1F4AC686633F3D47AAE51978F217E0C267999966BAF9452B3C973D11F616D709536186696B6D0D971FA071F6A25922CF60DF7D27EE1B6AB723F63F4C9CDCEE0AC458ADC1E0F9E66129F1B4B08F68BA79DAA4A36B5311A8440137DFEAEC74FC7C3BECC862D1B9BB635710E420F32BE70DDB25CD96C332CC9EF2A87E63025C35B8B6094F24C81CF8EB2D6A5C0F68920DB50952004406B892B50C6B6CA4173C759E00D74553608E788682CB9F8BC733CBBEE2ECBD3E371BCC65EC6C0EE1BC1CD93804EF7214BB9BBF3BFBFC7318EB27AD3243E429F9CDD3CC5EF7B4735D35A1AEC39E1E3612C8FD46F33D63A4B9ABAD6BB3167B4E7A0ECB476637D4281EBB1A1F39255D6FEEDEB8C6E632CA19731178B11533D2A3D66ABEB445C53BE0B7774778558F624F790BCE1AC191BF88BDC71BA8433658380528A77697C2B18E42460EE0188B1D62775D2747E4003AF158E57ECC0541F95C2AA1B3BD95DDADA5F07F9078DB793FA4D8F5B1BFF38D426F65C71E687EC59DB59E3A27F3A71D667443205030F4F291E616732B3CE855E7AD52B8F05DF745EC0AD92FC8E352DDAC0330F30078AACB607A2F876D7471E4DD418EAC9F986A7D0ABB42326F80ACC4CEBB9732137E6635C639A87374097EAF90398876BAAE90FBE4A04CC7C82E0717C9604980FC0BBF53B5BBE3982E21A70D5002EEB56E38DC2ED3968E7AD561877C06392A9381967DB30A238C937EDA4F1A9C276B95BB2FEBE4BD3976A835FA3CEE8891FE783E0C0C8A84F7A856A272A2D90326053B6AE17154A4BDE33A8EEA5228E94AFB3CAEAD3277E173BEE34ABCEFD9CB80CFDEA8F59DFA3E5CCA12E74D500B67CFBC19FD499CB788FCE4DBE8F09B2AE427DCB7F0BD5D0FEC82AF6A3156E60BB5B986CA3640A9899C5670D98F61BFB7C479FBD04496E90C208B637C2133651E1CE41CA722CFE1DADFA1CE0570BEDC3B7E20AFE92CE0ED1FF8E62A7E9E113F6717EFE3CCD9D889A51888F085EA2C07D3A6E2DE5F6C3CD071B7F1EE5499B726CEBBD6527D186B0C932F110D764FE05C27C479DDD9CB6E842B7E12775ED1FB908926F0AB9FE09CD86B8723CF721F16228C3D0C3BD7AFD157BEC01C0FC817E869B9983708D1F840B343105380E3EF8A345FDBE26EE3F02042F2B5C1D1EE695202DFE3FD770CEF1BE77F3A9EF038325507EC2C70703DD6792FC93D50B473579CECC44EF40AAECD44BE67A2864D9D8E938B7EDAA06330E76A6DE2CCE472F29BE97061880CE3FB039D803DD71638A997EC5FF1ED3FCC0B96B99D075F3E528769A95D87BDEB2270C34886E1BF181979023BBB01966FC27B603764ED4BE67B3C52ECBC1B6FE9F0739BF2AF2CFDD5B6D50C932E05A296EF927CCC79ECF1DA3868FA12A3ECF13092145747D71E8FD55F3DDDF17027971F91E861F5BABA82B017DDEDE1C856F9EF3743B08F3E73BE48FF3CFE3CFE3CFE3CFE3CFE3CFE3CFE3CFE3F1DFF0D7E09B72E]]>
                  </MeshData>
                </MeshImport>
              </Producers>
            </Mesh>
          </Definitions>
          <OnUpdate>
            <ZExpression Name="UpdateNotes">
              <Expression>
<![CDATA[int doRemove = 0;

// Move note
CurrentModel.Position.y += NoteStep;

// Update note's length if it's still being played
if (CurrentModel.noteIsActive)
{
  CurrentModel.totalDelta += CurDelta;
  CurrentModel.Scale.Y     = CurrentModel.totalDelta*NoteSpeed;
  CurrentModel.Position.y -= NoteStep/2;
}

// Base note width off initial velocity
CurrentModel.Scale.X = KeySpacing * 0.5 + KeySpacing * 0.5 * vel;

// Is the note currently crossing the keyboard?
if ( ((NoteDirection == 0) && (CurrentModel.Position.y - CurrentModel.Scale.Y/2 <= 0)) ||
     ((NoteDirection == 1) && (CurrentModel.Position.y + CurrentModel.Scale.Y/2 >= 0)) )
{
  inNote = 1;
}
else
{
  inNote = 0;
}

int p1 = currentModel.Position.y;
int p2 = NoteStart;
int p3 = CurrentModel.Scale.y;

// In the player mode, we don't want notes going past the piano...
if (PianoMode == 1)
{
  if  (inNote)
  {
    if (CurrentModel.noteIsActive)
    {
      CurrentModel.Position.y = NoteStart/2.0;
    }
    else
    {
      CurrentModel.Position.Y -= NoteStep/2.0;
    }

    CurrentModel.Scale.Y = abs(CurrentModel.Position.y*2);
  }
}

// If we're inside the note, we don't want it larger than source->0.
// Otherwise it flows through the keyboard.
notePosY = CurrentModel.Position.y;

// End note if it's not the current one
if (ActiveNotes[CurrentModel.noteIndex, CurrentModel.noteChannel] != CurrentModel)
{
  CurrentModel.noteIsActive = 0;
}

int key = keyFromNote(CurrentModel.noteIndex);

// PianoMode 1 is player mode, 0 is shooter mode.
if (PianoMode == 1)
{
  int clearKey = 0;

  // Clear the models as they fully cross the piano
  if ( ((NoteDirection == 0) && (CurrentModel.Position.y - CurrentModel.Scale.Y/2 < 0)) ||
      ((NoteDirection == 1) && (CurrentModel.Position.y + CurrentModel.Scale.Y/2 > 0)))
  {
    clearKey = 1;
  }

  if (clearKey)
  {
    doRemove = 1;
    // deactivate key here
    if (key >= 0)
    {
      KeyArray[key].isDown = 0;
    }
  }
  else
  {
    // Start the key down when the model hits / while it's present.
    if ((key >= 0) && (KeyArray[key].isDown == 0))
    {
      if (inNote == 1)
      {
        KeyArray[key].isDown = 1;
        KeyArray[key].lastChannel = CurrentModel.noteChannel;
        KeyArray[key].Position.Y = KeyPositions[key,1] - 1;
      }
    }

  }
}


// Set note color
vec3 curColor = getColor(CurrentModel.noteChannel, CurrentModel.noteIndex);
int colorSet = Parameters[P_COLOR_PALETTE] * 1000;
NoteColor.Color.R = curColor[0];
NoteColor.Color.G = curColor[1];
NoteColor.Color.B = curColor[2];
NoteColor.Color.A = NoteAlpha;
NoteMaterial.Color = NoteColor.Color;

// Destroy note if it's out of range and not active
if (CurrentModel.noteIsActive == 0)
{

  if (PianoMode == 0)
  {
    if ((CurrentModel.Position.y < -MaxModelY) ||
        (CurrentModel.Position.y > MaxModelY))
    {
      doRemove = 1;
    }
  }
}
// Clear all notes if flag set
if (ClearAllNotes > 0)
{
  doRemove = 1;
}

if (doRemove)
{
  if (ActiveNotes[CurrentModel.NoteIndex, CurrentModel.noteChannel] == CurrentModel)
  {
    ActiveNotes[CurrentModel.NoteIndex, CurrentModel.noteChannel] = null;
  }

  @RemoveModel();
}]]>
              </Expression>
            </ZExpression>
          </OnUpdate>
          <OnRender>
            <Condition Name="ShowNotes" Expression="return (Parameters[P_SHOW_NOTES] &gt; 0.5);">
              <OnTrue>
                <RenderSetColor Name="NoteColor" Color="1 0 0.502 0.9"/>
                <UseMaterial Material="noteMaterial"/>
                <Condition Name="meshNotes" Expression="return (Parameters[P_NOTE_TYPE] == 0.0);">
                  <OnTrue>
                    <RenderMesh Mesh="noteMesh"/>
                  </OnTrue>
                  <OnFalse>
                    <RenderSprite/>
                  </OnFalse>
                </Condition>
              </OnTrue>
            </Condition>
          </OnRender>
        </Model>
        <Model Name="PianoKeyModel" Scale="0.1 0.1 0.1">
          <Definitions>
            <Constant Name="ColorReturnStep" Value="0.1"/>
            <Constant Name="KeyReturnStep" Value="0.3"/>
            <Variable Name="isDown" Type="1"/>
            <Variable Name="lastChannel" Type="1"/>
            <Variable Name="materialType" Comment="0=Active" Type="1"/>
            <Variable Name="noteValue" Type="1"/>
            <Variable Name="particleColor" Type="8"/>
            <Variable Name="pressStep" Type="7"/>
            <Variable Name="visible" Type="1"/>
            <Mesh Name="KeyC_Origin">
              <Producers>
                <MeshImport>
                  <MeshData>
<![CDATA[789C354ECB0DC2500C73DBC7477C2406E0C008AC0037A6E84A2CC1029C3856ECC199011005F567EC54247A8EE338D1DB00D8C25155E4F31E14B783F811D8AB5E7680F1F400FE6805301FD1DDF53C6259BA373AAC31C2D55373A3FD5633144A4F3324611FDA1C2DA7B1DDEAD931302147CF9603ED9F28C7DBF6345CC07BD60B555F33FFB0E32BF83AFA814BD47CEBC20C2B75401F3FCBF592F63234E2B9BCDFD013BAB8FF035378756B]]>
                  </MeshData>
                </MeshImport>
              </Producers>
            </Mesh>
            <Mesh Name="KeyD_Origin">
              <Producers>
                <MeshImport>
                  <MeshData>
<![CDATA[789C358F3D12014114847BB17E5640E0000231AE40E6147B15B973C85D812A077000B15480AAB5B35AF70C3B353D6FFAEB37F5760260A61DB83892B793CA2D7058A95E034B9DFB2960DD5C81BFDA015C272D4B60374F6A723927B5435AFDD92B4BD249D29434B59ABAD77EBA67686BD9CFD09136D12B50B31F5FAAB4DB220D53A62BCAE805560C746F4FCB34E55BC8F1EF6DF44AAE0E484D9ECC62BEE69BA91E4596618C07EF7CB110B55F60A854FA9B979203F9E1770FFCFCE6F41CAD38BFEB8A9ED4F92F49C68E8A]]>
                  </MeshData>
                </MeshImport>
              </Producers>
            </Mesh>
            <Mesh Name="KeyE_Origin">
              <Producers>
                <MeshImport>
                  <MeshData>
<![CDATA[789C4D8F3172C2301444570E2436130A663800450E902B40C715D4B8A5CCA5E8A9E9E01ED47464D2648C1DBCEC4A9889345AFFFFFEEAEB7B0EE0035E5F07F27C4C21764BC52BE053DFED02B0AE4FC0A02680E3AC750DEC37595D21B39A9031E6AE66753DD4ECB7F2DFCAD518ED0878D1B6336024BD253641C731FE14FBD811F0AAC394D9115469D8D1D99BF630CD55F43D39CC27CA03FAC45B9628122F51A1659EB451874A4EBF533CBAF4EA4B168F7F2930C68FE6BAD077AB444BCC9E2F36E295F45BF154B4E32FEF0A71956A]]>
                  </MeshData>
                </MeshImport>
              </Producers>
            </Mesh>
            <Mesh Name="KeyF_Origin">
              <Producers>
                <MeshImport>
                  <MeshData>
<![CDATA[789C354EC90D02410CF3EE0E8738240AE04109B4003FAAD856288126688017CF157DF0A600C4A1BD8C9D1589C6711C279A1580351C55453E6E2247E0BA13DF035BD5F306301EEEC01FAD00E603BABB9C062C4BF746873546B87A6A6EB4DF6A8642E9698624EC429BA2E138B61B3D3B7A26E4E8D8B0A7FD23E570DB9E9A3378CF7AA1EA6BE61FB67C065F46DF738E375FBA30C1421DD0C5CF72BDA4BD0CB5782EEF37F48436EEFF00DDF875EB]]>
                  </MeshData>
                </MeshImport>
              </Producers>
            </Mesh>
            <Mesh Name="KeyG_Origin">
              <Producers>
                <MeshImport>
                  <MeshData>
<![CDATA[789C358F3D12014114847BFD5B01819C40247205320710EF555C4622172BEE21960A50B5EC6ADDF3A8A9E979D35FBFA9376300336D727222AF67955BF2B854BD02163A7753D3DD747D01FE6A07701D5A14C07E1E6AB23984DA21AD40F41405E924694A9A5A4DDD6B3FEE199A5AF633B4A475F272BCD94B2F95DA4D919A91E9883279154B56746F57CB34F20DB4F1EFADF54A5B1D909A3C98A5FC9B2F463D4C2CC30877DEF8642E6A3FC740A9F8CD53C9BEFCEA77AFF8F9CDE9391A697ED7253DA9F35F3F768EC6]]>
                  </MeshData>
                </MeshImport>
              </Producers>
            </Mesh>
            <Mesh Name="KeyA_Origin">
              <Producers>
                <MeshImport>
                  <MeshData>
<![CDATA[789C358F3116C140188467439E8882C201140EE00A74540A7DAEE2321AA7C01D946AAD02EF9130667663F7BDD9F9BF99BCDD8C014CE1B53E92D793CC1638CCE517C04CE76E02589717E0AF26807DD2AA02F6ABA44E36E7A426A4D5CBACAA483749A7A453AB537F6B9EE6808EB6794057FA892CD3FE465F2AEBC456C38679DB459C5F229E7BDAA6E62F66C85120F90F0B4D41691E930743ECD77C33F961CC0246B8F3C6274BA5E625066AA5BB9E6AF6C59B76F6AD993A35EBF8DABC7DEF9B5DFD83FB3F912E8BF8]]>
                  </MeshData>
                </MeshImport>
              </Producers>
            </Mesh>
            <Mesh Name="KeyB_Origin">
              <Producers>
                <MeshImport>
                  <MeshData>
<![CDATA[789C3D4DC10DC2300CBC505A104888017830022BC08F0733640456601976E00B7BF0660054556AD21E3E47C551CEE7F3D9DE02D841717B929F9708F0381A3F0107CBF73D203CBF8109A500E20563042ED782EA904285728CA526E511F21F4040654FDD80B9E1E0DA12893546E3D97E71D48699BD394A5563BA944C5D4173D2351B7C3631B3C1CCF5060BDF257F6F7AE5FB605DEDA75FCAFC726447F9373E33708D962D7F06C7738D]]>
                  </MeshData>
                </MeshImport>
              </Producers>
            </Mesh>
            <Mesh Name="KeySharp_Powder">
              <Producers>
                <MeshImport>
                  <MeshData>
<![CDATA[789C3D8C5D0E40400C8467FD44789238D13A8157B7F1EC142E42C4ADD8D8D16E314DDAAF9DB60D8016AA7DDFB6F9109880C10BF7C0E2D5F1236979ED94349B80AF1AE197B243F6522E01E9ACBFD3A6B2CDC99315029D702913FDA45C487C7F2303232FB905EAE4910F4CA74757]]>
                  </MeshData>
                </MeshImport>
              </Producers>
            </Mesh>
            <Material Name="ActiveMaterial"/>
            <Material Name="BlackKeyMaterial" Color="0.1608 0.1608 0.1608 1" Shininess="0.14"/>
            <Material Name="WhiteKeyMaterial"/>
          </Definitions>
          <OnUpdate>
            <ZExpression>
              <Expression>
<![CDATA[if (visible)
{
  vec3 curColor = getColor(currentModel.lastChannel, currentModel.noteValue);

  ActiveMaterial.Color.R = curColor[0];
  ActiveMaterial.Color.G = curColor[1];
  ActiveMaterial.Color.B = curColor[2];

  if (isDown > 0)
  {
     sprayEmitter.ParticlesPerSecond = 10;

    currentModel.particleColor[0] = curColor[0];
    currentModel.particleColor[1] = curColor[1];
    currentModel.particleColor[2] = curColor[2];
    currentModel.particleColor[3] = 0.5;

    if (Parameters[P_LIGHT_KEYS] > 0.5)
    {
      materialType = 2;
    }
    else
    {
      materialType = isNoteBlack(NoteValue);
    }

  }
  else
  {
    // Sloppy but works - should make a filter class.
    // This filters the keys as they are released so
    // it isn't as digital
    // Need to add in multiplier off delta time.
    int key = keyFromNote(CurrentModel.NoteValue);
    if (key > -1)
    {
      // Have to do X now for arc
      if (CurrentModel.Position.X - KeyPositions[key,0] < -KeyReturnStep)
        CurrentModel.Position.X += KeyReturnStep;
      else if (CurrentModel.Position.X - KeyPositions[key,0]> KeyReturnStep)
        CurrentModel.Position.X -= KeyReturnStep;
      else
        CurrentModel.Position.X = KeyPositions[key,0];

      if (CurrentModel.Position.Y - KeyPositions[key,1] < -KeyReturnStep)
        CurrentModel.Position.Y += KeyReturnStep;
      else if (CurrentModel.Position.Y - KeyPositions[key,1]> KeyReturnStep)
        CurrentModel.Position.Y -= KeyReturnStep;
      else
        CurrentModel.Position.Y = KeyPositions[key,1];

      if (CurrentModel.Position.Z - KeyPositions[key,2] < -KeyReturnStep)
        CurrentModel.Position.Z += KeyReturnStep;
      else if (CurrentModel.Position.Z - KeyPositions[key,2] > KeyReturnStep)
        CurrentModel.Position.Z -= KeyReturnStep;
      else
        CurrentModel.Position.Z = KeyPositions[key,2];
    }

    // Particle color
    if (currentModel.particleColor[0] > ColorReturnStep)
      CurrentModel.particleColor[0] -= ColorReturnStep;
    else
      CurrentModel.particleColor[0] = 0;

    if (currentModel.particleColor[1] > ColorReturnStep)
      CurrentModel.particleColor[1] -= ColorReturnStep;
    else
      CurrentModel.particleColor[1] = 0;

    if (currentModel.particleColor[2] > ColorReturnStep)
      CurrentModel.particleColor[2] -= ColorReturnStep;
    else
      CurrentModel.particleColor[2] = 0;

     sprayEmitter.ParticlesPerSecond = 0;
    // Key material
    materialType = isNoteBlack(NoteValue);
  }
}]]>
              </Expression>
            </ZExpression>
          </OnUpdate>
          <OnRender>
            <Condition Name="If_Key_Is_Used" Expression="return (CurrentModel.visible == 1);">
              <OnTrue>
                <Condition Name="If_Show_Piano" Expression="return (Parameters[P_SHOW_PIANO] &gt; 0.5);">
                  <OnTrue>
                    <Condition Name="cond_is_it_active" Expression="return (CurrentModel.IsDown );">
                      <OnTrue>
                        <UseMaterial Material="ActiveMaterial"/>
                      </OnTrue>
                      <OnFalse>
                        <Condition Name="cond_is_it_black" Expression="return (materialType == 1);">
                          <OnTrue>
                            <UseMaterial Material="BlackKeyMaterial"/>
                          </OnTrue>
                          <OnFalse>
                            <UseMaterial Material="WhiteKeyMaterial"/>
                          </OnFalse>
                        </Condition>
                      </OnFalse>
                    </Condition>
                    <Condition Name="RenderC" Expression="return ((NoteValue % 12) == 0);">
                      <OnTrue>
                        <RenderMesh Mesh="KeyC_Origin"/>
                      </OnTrue>
                    </Condition>
                    <Condition Name="RenderC1" Expression="return ((NoteValue % 12) == 1);">
                      <OnTrue>
                        <RenderMesh Mesh="KeySharp_Powder"/>
                      </OnTrue>
                    </Condition>
                    <Condition Name="RenderD" Expression="return ((NoteValue % 12) == 2 );">
                      <OnTrue>
                        <RenderMesh Mesh="KeyD_Origin"/>
                      </OnTrue>
                    </Condition>
                    <Condition Name="RenderD1" Expression="return ((NoteValue % 12) == 3);">
                      <OnTrue>
                        <RenderMesh Mesh="KeySharp_Powder"/>
                      </OnTrue>
                    </Condition>
                    <Condition Name="RenderE" Expression="return ((NoteValue % 12) == 4);">
                      <OnTrue>
                        <RenderMesh Mesh="KeyE_Origin"/>
                      </OnTrue>
                    </Condition>
                    <Condition Name="RenderF" Expression="return ((NoteValue % 12) == 5);">
                      <OnTrue>
                        <RenderMesh Mesh="KeyF_Origin"/>
                      </OnTrue>
                    </Condition>
                    <Condition Name="RenderF1" Expression="return ((NoteValue % 12) == 6);">
                      <OnTrue>
                        <RenderMesh Mesh="KeySharp_Powder"/>
                      </OnTrue>
                    </Condition>
                    <Condition Name="RenderG" Expression="return ((NoteValue % 12) == 7);">
                      <OnTrue>
                        <RenderMesh Mesh="KeyG_Origin"/>
                      </OnTrue>
                    </Condition>
                    <Condition Name="RenderG1" Expression="return ((NoteValue % 12) == 8 );">
                      <OnTrue>
                        <RenderMesh Mesh="KeySharp_Powder"/>
                      </OnTrue>
                    </Condition>
                    <Condition Name="RenderA" Expression="return ((NoteValue % 12) == 9);">
                      <OnTrue>
                        <RenderMesh Mesh="KeyA_Origin"/>
                      </OnTrue>
                    </Condition>
                    <Condition Name="RenderA1" Expression="return ((NoteValue % 12) == 10);">
                      <OnTrue>
                        <RenderMesh Mesh="KeySharp_Powder"/>
                      </OnTrue>
                    </Condition>
                    <Condition Name="RenderB" Expression="return ((NoteValue % 12) == 11);">
                      <OnTrue>
                        <RenderMesh Mesh="KeyB_Origin"/>
                      </OnTrue>
                    </Condition>
                  </OnTrue>
                </Condition>
                <Condition Name="If_Show_Particles" Expression="return (Parameters[P_SHOW_PARTICLES] &gt; 0.5);">
                  <OnTrue>
                    <RenderParticles Name="sprayEmitter" ParticlesPerSecond="10" Spread="50" ParticleWidth="8" ParticleHeight="8" Speed="20" SpeedRange="10" Radius="5" ParticleLifetime="1" AnimateAlpha="-0.5" AnimateSize="-7" Damping="1">
                      <OnEmitExpression>
<![CDATA[//Emit particle.
//PColor : particle color, PAngle : particle angle
PAngle = random(0,.2);

float bright = 0;
if (currentModel.isDown > 0)
{
  bright = random(0.5,0.5);
}
PColor.r = currentModel.particleColor[0] - bright;
PColor.g = currentModel.particleColor[1] - bright;
PColor.b = currentModel.particleColor[2] - bright;]]>
                      </OnEmitExpression>
                    </RenderParticles>
                  </OnTrue>
                </Condition>
              </OnTrue>
            </Condition>
          </OnRender>
        </Model>
      </Children>
    </Group> <!-- PianoData -->

  </Content>
</ZApplication>
